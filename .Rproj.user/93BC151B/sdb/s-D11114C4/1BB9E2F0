{
    "contents" : "### Advanced Factor Functions V1.03  2013/03/17\n### 2013 James H. Steiger\npackageLoaded <- function(name) 0 != length(grep(paste(\"^package:\", \n                                                       name, \"$\", sep=\"\"), search()))\n\nif(!packageLoaded(\"plotrix\")) library(plotrix)\n\n\n# This code block includes R code for \n#\n# Gradient Projection Algorithms and Software for Arbitrary\n# Rotation Criteria in Factor Analysis.\n#\n# by:\n#\n# Coen A. Bernaards and Robert I. Jennrich.\n#\n# Website: http://www.stat.ucla.edu/research\n# \n\n# GPForth is the main GP algorithm for orthogonal rotation.\n# GPFoblq is the main GP algorithm for oblique rotation.\n# For both algorithms is required: a loadings matrix A. Optional  \n# a initial rotation matrix Tmat. By default this is the identity matrix.\n# Optional: the rotation method to be used. Between quation marks have to\n# be the last part of the name of the vgQ function, e.g. for vgQ.varimax\n# the argument is \"varimax\". Identical arguments can be used for oblique\n# rotation. Some rotation criteria (including simplimax, pst, procrustes, \n# cf,...) require one or more additional arguments. For example, simplimax\n# needs the number of 'close to zero loadings'. This is given included as\n# the extra argument k=27. Check out the rotation methods for details. \n# When a new rotation method is implemented, and it needs an additional\n# argument then this is the easiest way to pass it to the function. \n#\n# New rotation methods need to be programmed as vgQ.newmethod. The only\n# inputs are the matrix L, and potential additional arguments. The\n# output consists of the value f  of the criterion, its gradient Gq at L,\n# and the name of the method.\n\nGPForth <- function(A,Tmat=diag(ncol(A)),method=\"varimax\",...){\n  al <- 1\n  L <- A %*% Tmat\n  VgQ <- get(paste(\"vgQ\",method,sep=\".\"))(L,...)\n  G <- crossprod(A,VgQ$Gq)\n  f <- VgQ$f\n  Table <- NULL\n  for (iter in 0:500){\n    M <- crossprod(Tmat,G)\n    S <- (M+t(M))/2\n    Gp <- G - Tmat %*% S\n    s <- sqrt(sum(diag(crossprod(Gp))))\n    Table <- rbind(Table,c(iter,f,log10(s),al))\n    if (s < 1e-5) \n      break\n    al <- 2*al\n    for (i in 0:10){\n      X <- Tmat - al * Gp\n      UDV <- svd(X)\n      Tmatt <- UDV$u %*% t(UDV$v)\n      L <- A %*% Tmatt\n      VgQt <- get(paste(\"vgQ\",method,sep=\".\"))(L,...)\n      if (VgQt$f < (f-.5*s^2*al))\n        break\n      al <- al/2\n    }\n    Tmat <- Tmatt\n    f <- VgQt$f\n    G <- crossprod(A,VgQt$Gq)\n  }\n  Th <- Tmat\n  Lh <- L\n  method <- VgQ$Method\n  orthogonal <- T\n  ## Added by Steiger\n  colnames(Table) <- c(\"Iteration\", \"Function\", \"Log10(s)\",\"Alpha\")\n  ##\n  return(list(Lh=Lh,Th=Th,Table=Table,method=method,orthogonal=orthogonal))\n}\n\nGPFoblq <- function(A,Tmat=diag(ncol(A)),method=\"quartimin\",...){\n  al <- 1\n  L <- A %*% t(solve(Tmat))\n  VgQ <- get(paste(\"vgQ\",method,sep=\".\"))(L,...)\n  G <- -t(t(L) %*% VgQ$Gq %*% solve(Tmat))\n  f <- VgQ$f\n  Table <- NULL\n  for (iter in 0:500){\n    Gp <- G-Tmat %*% diag(apply(Tmat*G,2,sum))\n    s <- sqrt(sum(diag(crossprod(Gp))))\n    Table <- rbind(Table,c(iter,f,log10(s),al))\n    if (s < 1e-5)\n      break\n    al <- 2*al\n    for (i in 0:10){\n      X <- Tmat-al*Gp\n      v <- 1/sqrt(apply(X^2,2,sum))\n      Tmatt <- X %*% diag(v)\n      L <- A %*% t(solve(Tmatt))\n      VgQt <- get(paste(\"vgQ\",method,sep=\".\"))(L,...)\n      if (VgQt$f < (f-.5*s^2*al))\n        break\n      al <- al/2\n    }\n    Tmat <- Tmatt\n    f <- VgQt$f\n    G <- -t(t(L) %*% VgQt$Gq %*% solve(Tmatt))\n    \n  }\n  Th <- Tmat\n  Lh <- L\n  Phi <- t(Tmat) %*% Tmat\n  method <- VgQ$Method\n  orthogonal <- F\n  return(list(Lh=Lh,Phi=Phi,Th=Th,Table=Table,method=method,orthogonal=orthogonal))\n}\n\n\nvgQ.quartimin <- function(L){\n  Method=\"Quartimin\"\n  L2 <- L^2\n  k <- ncol(L)\n  M <- matrix(1,k,k)-diag(k)\n  f <- sum(L2 * (L2 %*% M))/4\n  Gq <- L * (L2 %*% M)\n  return(list(Gq=Gq,f=f,Method=Method))\n} \n\nvgQ.oblimin <- function(L,gam=0){\n  Method <- paste(\"Oblimin g=\",gam,sep=\"\")\n  if (gam == 0) Method <- \"Oblimin Quartimin\"\n  if (gam == .5) Method <- \"Oblimin Biquartimin\"\n  if (gam == 1) Method <- \"Oblimin Covarimin\"\n  k <- ncol(L)\n  p <- nrow(L)\n  N <- matrix(1,k,k)-diag(k)\n  f <- sum(L^2 * (diag(p)-gam*matrix(1/p,p,p)) %*% L^2 %*% N)/4\n  Gq <- L * ((diag(p)-gam*matrix(1/p,p,p)) %*% L^2 %*% N)\n  return(list(Gq=Gq,f=f,Method=Method))\n}\n\nvgQ.target <- function(L,Target){\n  Method <- \"Target rotation\"\n  # Needs Target matrix, e.g.  Target <- matrix(c(rep(9,4),rep(0,8),rep(9,4)),8) \n  f <- sum((L-Target)^2)\n  Gq <- 2*(L-Target)\n  return(list(Gq=Gq,f=f,Method=Method))\n}\n\nvgQ.pst <- function(L,W,Target){\n  Method <- \"Partially specified target\"\n  # Needs weight matrix W with 1's at specified values, 0 otherwise\n  # e.g. W = matrix(c(rep(1,4),rep(0,8),rep(1,4)),8). \n  # When W has only 1's this is procrustes rotation\n  # Needs a Target matrix Target with hypothesized factor loadings.\n  # e.g. Target = matrix(0,8,2)\n  Btilde <- W * Target\n  f <- sum((W*L-Btilde)^2)\n  Gq <- 2*(W*L-Btilde)\n  return(list(Gq=Gq,f=f,Method=Method))\n}\n\nvgQ.oblimax <- function(L){\n  Method <- \"Oblimax\"\n  f <- -(log(sum(L^4))-2*log(sum(L^2)))\n  Gq <- -(4*L^3/(sum(L^4))-4*L/(sum(L^2)))\n  return(list(Gq=Gq,f=f,Method=Method))\n}\n\nvgQ.entropy <- function(L){\n  Method <- \"Minimum entropy\" \n  f <- -sum(L^2 * log(L^2 + (L^2==0)))/2\n  Gq <- -(L * log(L^2 + (L^2==0)) + L)\n  return(list(Gq=Gq,f=f,Method=Method))\n}\n\nvgQ.quartimax <- function(L){\n  Method <- \"Quartimax\"\n  f <- -sum(diag(crossprod(L^2)))/4\n  Gq <- -L^3\n  return(list(Gq=Gq,f=f,Method=Method))\n}\n\nvgQ.varimax <- function(L){\n  Method <- \"Varimax\"\n  QL <- sweep(L^2,2,apply(L^2,2,mean),\"-\")\n  f <- -sqrt(sum(diag(crossprod(QL))))^2/4\n  Gq <- -L * QL\n  return(list(Gq=Gq,f=f,Method=Method))\n}\n\nvgQ.simplimax <- function(L,k=nrow(L)){\n  Method <- \"Simplimax\"\n  # m: Number of close to zero loadings\n  Imat <- sign(L^2 <= sort(L^2)[k])\n  f <- sum(Imat*L^2)\n  Gq <- 2*Imat*L\n  return(list(Gq=Gq,f=f,Method=Method))\n}\n\nvgQ.bentler <- function(L){\n  Method <- \"Bentler's criterion\"\n  L2 <- L^2\n  M <- crossprod(L2)\n  D <- diag(diag(M))\n  f <- -(log(det(M))-log(det(D)))/4\n  Gq <- -L * (L2 %*% (solve(M)-solve(D)))\n  return(list(Gq=Gq,f=f,Method=Method))\n}\n\nvgQ.tandemI <- function(L){  # Tandem Criterion, Comrey, 1967.\n  Method <- \"Tandem I\"\n  LL <- (L %*% t(L))\n  LL2 <- LL^2\n  f <- -sum(diag(crossprod(L^2, LL2 %*% L^2)))\n  Gq1 <- 4 * L *(LL2 %*% L^2)\n  Gq2 <- 4 * (LL * (L^2 %*% t(L^2))) %*% L\n  Gq <- -Gq1 - Gq2 \n  return(list(Gq=Gq,f=f,Method=Method))\n}\n\nvgQ.tandemII <- function(L){  # Tandem Criterion, Comrey, 1967.\n  Method <- \"Tandem II\"\n  LL <- (L %*% t(L))\n  LL2 <- LL^2\n  f <- sum(diag(crossprod(L^2, (1-LL2) %*% L^2)))\n  Gq1 <- 4 * L *((1-LL2) %*% L^2)\n  Gq2 <- 4 * (LL * (L^2 %*% t(L^2))) %*% L\n  Gq <- Gq1 - Gq2 \n  return(list(Gq=Gq,f=f,Method=Method))\n}\n\nvgQ.geomin <- function(L,eps=.01){\n  Method <- \"Geomin\"\n  k <- ncol(L)\n  p <- nrow(L)\n  L2 <- L^2+eps\n  pro <- exp(apply(log(L2),1,sum)/k) \n  f <- sum(pro)\n  Gq <- (2/k)*(L/L2)*matrix(rep(pro,k),p)\n  return(list(Gq=Gq,f=f,Method=Method))\n}\n\nvgQ.cf <- function(L,kappa=0){\n  k <- ncol(L)\n  p <- nrow(L)\n  # kappa <- 0 # Quartimax \n  # kappa <- 1/p # Varimax\n  # kappa <- m/(2*p) # Equamax\n  # kappa <- (m-1)/(p+m-2) # Parsimax\n  # kappa <- 1 # Factor parsimony\n  Method <- paste(\"Crawford-Ferguson:k=\",kappa,sep=\"\")\n  N <- matrix(1,k,k)-diag(k)\n  M <- matrix(1,p,p)-diag(p)\n  L2 <- L^2\n  f1 <- (1-kappa)*sum(diag(crossprod(L2,L2 %*% N)))/4\n  f2 <- kappa*sum(diag(crossprod(L2,M %*% L2)))/4\n  f <- f1 + f2\n  Gq <- (1-kappa) * L * (L2 %*% N) + kappa * L * (M %*% L2)\n  return(list(Gq=Gq,f=f,Method=Method))\n}\n\nvgQ.infomax <- function(L){\n  Method <- \"Infomax\"\n  k <- ncol(L)\n  p <- nrow(L)\n  S <- L^2\n  s <- sum(S)\n  s1 <- apply(S, 1, sum)\n  s2 <- apply(S, 2, sum)\n  E <- S/s\n  e1 <- s1/s\n  e2 <- s2/s\n  Q0 <- sum(-E * log(E))\n  Q1 <- sum(-e1 * log(e1))\n  Q2 <- sum(-e2 * log(e2))\n  f <- log(k) + Q0 - Q1 - Q2\n  H <- -(log(E) + 1)\n  alpha <- sum(S * H)/s^2\n  G0 <- H/s - alpha * matrix(1, p, k)\n  h1 <- -(log(e1) + 1)\n  alpha1 <- s1 %*% h1/s^2\n  G1 <- matrix(rep(h1,k), p)/s - as.vector(alpha1) * matrix(1, p, k)\n  h2 <- -(log(e2) + 1)\n  alpha2 <- h2 %*% s2/s^2\n  G2 <- matrix(rep(h2,p), ncol=k, byrow=T)/s - as.vector(alpha2) * matrix(1, p, k)\n  Gq <- 2 * L * (G0 - G1 - G2)\n  return(list(Gq=Gq,f=f,Method=Method))\n}\n\nvgQ.mccammon <- function(L){\n  Method <- \"McCammon entropy\"\n  k <- ncol(L)\n  p <- nrow(L)\n  S <- L^2\n  M <- matrix(1,p,p)\n  s2 <- apply(S, 2, sum)\n  P <- S / matrix(rep(s2,p),ncol=k,byrow=T)\n  Q1 <- -sum(P * log(P))\n  H <- -(log(P) + 1)\n  R <- M %*% S\n  G1 <- H/R - M %*% (S*H/R^2)\n  s <- sum(S)\n  p2 <- s2/s\n  Q2 <- -sum(p2 * log(p2))\n  h <- -(log(p2) + 1)\n  alpha <- h %*% p2\n  G2 <- rep(1,p) %*% t(h)/s - as.vector(alpha)*matrix(1,p,k)\n  Gq <- 2*L*(G1/Q1 - G2/Q2)\n  Q <- log(Q1) - log(Q2)\n  return(list(Gq=Gq,f=Q,Method=Method))\n}\n\n#\n# GPromax is a separate function!!!\n# Call directly from command prompt.\n# R code only.\n# \nGPromax <- function(A,pow=3){\n  method <- \"Promax\"\n  # Initial rotation: Standardized Varimax\n  #require(mva)\n  xx <- promax(A,pow)\n  Lh <- xx$loadings\n  Th <- xx$rotmat\n  orthogonal <- F\n  Table <- NULL\n  return(list(Lh=Lh,Th=Th,Table=NULL,method,orthogonal=orthogonal))\n}\n\n\n##\n## UTILITY FUNCTIONS\n\n##\n\n# Kaisers standardized variables\n\n# Can be used for standardization and de-standardization.\n\n# For standardization: only provide 1 argument: the matrix A\n\n# output: standardized A and weights W\n\n# For destandardization: provide 2 arguments: matrix A\n\n# and weights W.\n\n# output: destandardized A and weights W.\n\nStandardize <- function(A,W){\n  \n  if (nargs()==1)\n    \n    W <- sqrt(apply(A^2,1,sum))\n  else\n    \n    W <- 1/W\n  \n  A <- sweep(A,1,W,\"/\")\n  \n  return(A,W)\n}\n\n\n\n# Random Start\n\n# k: number of dimensions\n\n# orthogonal random start? (Yes, by default).\n\nRandom.Start <- function(k,orthogonal=T){\n  \n  mat <- matrix(rnorm(k*k),k)\n  \n  if (orthogonal){\n    ans <- qr.Q(qr(mat))\n  }\n  \n  else{\n    \n    ans <- mat %*% diag(sqrt(1/diag(t(mat) %*% mat)))\n    \n  }\n  \n  ans\n  \n} \n\n\n########## Following routines added by Steiger\n\nvgQ.bifactor <- function(L){\n  Method <- \"bifactor\"\n  k <- dim(L)[2]\n  p <- dim(L)[1]\n  L <- L[,2:k]\n  Lsq <- L * L\n  M <- matrix(1,k-1,k-1) - diag(k-1)\n  f <- sum(Lsq * (Lsq %*% M))\n  zero <- matrix(0,p,1)\n  Gq <- 4*cbind(zero, L * (Lsq %*% M))\n  return(list(Gq=Gq,f=f,Method=Method))\n}\n\n################  End of Augmented Jennrich-Bentler Functions ############\n\n\n################ The following code block augments some service\n################ functions for Exploratory Factor Analysis with R\n##########################################################################\n\n\n\nsx2 <- function(df, lambda)\n{\n  x <- 2 * df + 4 * lambda\n  if(x<0)x<-0\n  return(sqrt(x))\n}\n\nFindLambda <- function(X2Observed,Df,CumP)\n{\n  \n  ##should get symbolic integer codes for droot_c\n  ##compute rough approximation to the start value\n  ErrorCondition <- FALSE\n  if (pchisq(X2Observed, Df) < CumP)\n  {\n    print(\"No non-negative value of Lambda will produce the desired cumulative probability.\")\n    return(NA)\n  }\n  zgoal <- qnorm(CumP)   \n  df <- Df\n  lambda1 <- X2Observed - df\n  if(lambda1 < 0) lambda1 <- 0\n  s1 <- sx2(df, lambda1)\n  lambda2 <- lambda1 - s1 * zgoal  ##temporary guess for lambda2\n  s2 <- sx2(df, lambda2)\n  s_est <- (s1 + s2) / 2\n  lambda2 <- lambda1 - zgoal * s_est\n  if(lambda2 < 0) lambda2 <- 0\n  pp2<-pchisq(X2Observed, Df, lambda2)-CumP\n  s1 <- sx2(df,lambda2)\n  z <-( X2Observed - df - lambda2)/s1\n  lambda3 <- lambda2 - s1 * (z-zgoal)  ##temporary guess for lambda2\n  s2 <- sx2(df, lambda3)\n  s_est <- (s1 + s2) / 2\n  lambda3 <- lambda2 - (z-zgoal) * s_est\n  if(lambda3 < 0)\n  {\n    lambda3 <- 0\n  }\n  pp3<-pchisq(X2Observed, Df, lambda3)-CumP\n  ##   should be in a linear range by now\n  if((pp2-pp3)!= 0)\n  {\n    xstart <- lambda3 - pp3 * ((lambda2-lambda3)/(pp2-pp3))\n  }  \n  n<-1\n  maxit<-10000\n  step<-1.e-4\n  eps<-1.e-10\n  \n  \n  xstart<-max(xstart,1)\n  if(abs(pchisq(X2Observed, Df)-CumP) <= eps)\n  {\n    return(0)\n  }\n  xold<-0\n  xc<-xstart\n  fc<-pchisq(X2Observed, Df, xc)-CumP\n  if(ErrorCondition)\n  {\n    return(NA)\n  }\n  hc<-max(step*xc,eps)\n  xnew<-xc-hc\n  fnew<-pchisq(X2Observed, Df, xnew)-CumP\n  if(ErrorCondition)\n  {\n    return(NA)\n  }\n  ac<-(fc-fnew)/hc\n  while ( abs(xnew-xold) > eps && n < maxit && abs(fc) > eps && abs(ac) >= 1.e-35)\n  {\n    n<-n+1\n    xnew<-xc-fc/ac\n    xold<-xc\n    fold<-fc\n    xc<-xnew\n    fc<-pchisq(X2Observed, Df, xnew)-CumP\n    ac<-(fold-fc)/(xold-xc)\n    if(ErrorCondition)\n    {\n      return(NA)\n    }\n    \n  }\n  ##iteration complete\n  if( (n >= maxit)||(abs(fc) > eps))\t  \n  {\n    ErrorCondition <- TRUE\n    print(\"Percentage point convergence failure.\")\n    return(NA)\n  }\n  else\n  {\n    return(xc)\t\n  }\n}\nChiSquare.Lambda.CI <- function(X2Observed,Df,Confidence=.90){\n  p <- (1. - Confidence)/2.\n  if( pchisq(X2Observed, Df) <= p)\n  {\n    Upper <- 0.\n    Lower <- 0.\n    return(c(Lower,Upper))\n  }\n  Upper <- FindLambda(X2Observed,Df,p)\n  if(pchisq(X2Observed, Df) <= 1.-p)\n  {\n    Lower  <- 0\n    return(c(Lower,Upper))\n  }\n  Lower <- FindLambda(X2Observed,Df,1-p)\n  return(c(Lower,Upper))\n}\n\nrmsea.ci <- function(chisq,df,n,conf=.90){\n  options(warn=-1)\n  sample.rmsea <- sqrt(max(((chisq-df)/(n-1)),0)/df)\n  #  out <- conf.limits.nc.chisq(Chi.Square=chisq,conf.level=conf,df=df,Jumping.Prop=0.001)\n  out<-ChiSquare.Lambda.CI(chisq,df,conf)\n  lower <- if(is.na(out[1])) 0 else out[1]\n  upper <- if(is.na(out[2])) 0 else out[2]\n  lower <- sqrt(lower/(n-1)/df)\n  upper <- sqrt(upper/(n-1)/df)\n  results <- list(Lower.Limit= lower, \n                  Point.Estimate = sample.rmsea,\n                  Upper.Limit = upper,\n                  Confidence.Level = conf)\n  return((results))\n}\n\nFA.Stats <- function(Correlation.Matrix,n.obs,n.factors,conf=.90,\n                     maxit=1000,RMSEA.cutoff=NULL,\n                     main=\"RMSEA Plot\",sub=NULL){\n  runs <- length(n.factors)  \n  R <- Correlation.Matrix\n  maxfac <- max(n.factors)\n  res <- matrix(NA,runs,8)\n  roots <- eigen(R)$values\n  for(i in 1:runs){\n    output <- factanal(covmat=R,n.obs=n.obs,factors=n.factors[i],maxit=maxit)\n    X2 <- output$STATISTIC\n    df <- output$dof\n    ci <- rmsea.ci(X2,df,n.obs,conf)\n    pvar <- sum(roots[1:n.factors[i]])\n    v <- c(n.factors[i],pvar,X2,df,1-pchisq(X2,df),ci$Point.Estimate,\n           ci$Lower.Limit,ci$Upper.Limit)\n    \n    res[i,] <- v\n  }\n  colnames(res)=c(\"Factors\",\"Cum.Eigen\",\"Chi-Square\",\"Df\",\"p.value\",\n                  \"RMSEA.Pt\",\"RMSEA.Lo\",\"RMSEA.Hi\")\n  plotCI(n.factors,res[,6],li = res[,7],ui=res[,8],\n         ylab=\"RMSEA\",xlab=\"Number of Factors\",main=main,\n         sub=sub)\n  lines(n.factors,res[,6],col=\"blue\")\n  abline(h=0,col=\"black\",lty=3)\n  abline(h=RMSEA.cutoff,col=\"red\",lty=2)\n  \n  return(res)\n}\n\nScree.Plot <- function(R,main=\"Scree Plot\",sub=NULL){\n  roots <- eigen(R)$values\n  x <- 1:dim(R)[1]\n  plot(x,roots,type=\"b\",col='blue',ylab=\"Eigenvalue\",\n       xlab=\"Component Number\",main=main,sub=sub) \n  abline(h=1,lty=2,col=\"red\")\n  \n}\n\nFindBifactor <- function(A,reps){\n  warn=-1\n  results <- rep( list(list()), reps ) \n  criterion <- rep(NA,reps)\n  m <- dim(A)[2]\n  for(i in 1:reps) {\n    x <- GPForth(A,method=\"bifactor\",Tmat = Random.Start(m))\n    criterion[i] <- min(x$Table[,2])\n    results[[i]] <- x\n  }\n  j <- order(criterion)[1]\n  warn=1\n  return(results[[j]])\n}\n\nFindBestPattern <- function(A,method,is.oblique=FALSE,reps=15){\n  results <- rep( list(list()), reps ) \n  criterion <- rep(NA,reps)\n  m <- dim(A)[2]\n  for(i in 1:reps) {\n    if(!is.oblique)x <- GPForth(A,method=method,Tmat = Random.Start(m))else\n      x <- GPFoblq(A,method=method,Tmat=Random.Start(m))\n    criterion[i] <- min(x$Table[,2])\n    results[[i]] <- x\n  }\n  j <- order(criterion)[1]\n  return(results[[j]])\n}\n\nFixPattern <- function(res,sort=TRUE){\n  F <- res$Lh\n  p <- dim(F)[1]\n  m <- dim(F)[2]\n  factor.names <- paste(\"Factor\",1:m,sep=\"\")\n  one.prime <- matrix(1,1,p)\n  F.sign <- as.vector(sign(one.prime %*% F))\n  #  cat(\"\\nLoadings:\\n\")\n  #  fx <- format(round(Lambda, digits))\n  #  names(fx) <- NULL\n  #  nc <- nchar(fx[1L], type=\"c\")\n  #  fx[abs(Lambda) < cutoff] <- paste(rep(\" \", nc), collapse = \"\")\n  #  print(fx, quote = FALSE, ...) \n  #  F <- Lambda\n  #fix signs\n  Lambda <- F\n  Lambda <- Lambda %*% diag(F.sign)\n  #sort columns by SS loadings\n  mx <- diag(t(Lambda)%*%Lambda)\n  ind <- order(mx,decreasing=TRUE)\n  Lambda <- Lambda[,ind]\n  #  browser()\n  #  print(res$orthogonal)\n  #  print(res$Phi)\n  if(!res$orthogonal)\n  {\n    #   fix up Phi\n    Phi <- diag(F.sign) %*% res$Phi %*% diag(F.sign)\n    Phi <- Phi[ind,]\n    Phi <- Phi[,ind]\n  }\n  if (sort) {\n    mx <- max.col(abs(Lambda))\n    ind <- cbind(1L:p, mx)\n    mx[abs(Lambda[ind]) < 0.4] <- m + 1\n    Lambda <- Lambda[order(mx, 1L:p),]\n  }\n  colnames(Lambda) <- factor.names\n  res$Lh <- Lambda\n  if(!res$orthogonal)\n  {\n    colnames(Phi) <- factor.names\n    rownames(Phi) <- factor.names\n    res$Phi <- Phi\n  }\n  return(res)\n}\n\nFindBifactorPattern <- function(A,reps,digits=2) {\n  options(warn=-1)\n  p<-dim(A)[1]\n  out <- FindBifactor(A,reps)\n  F <- out$Lh\n  one.prime <- matrix(1,1,p)\n  F.sign <- as.vector(sign(one.prime %*% F))\n  F <- F %*% diag(F.sign)\n  options(warn=1)\n  return(round(F,digits))\n}\n\nGPromax <- function(A,pow=3){\n  method <- \"Promax\"\n  # Initial rotation: Standardized Varimax\n  xx <- promax(A,pow)\n  Lh <- xx$loadings\n  Th <- xx$rotmat\n  orthogonal <- F\n  Table <- NULL\n  Tinv <- solve(Th)\n  Phi <- Tinv %*% t(Tinv)\n  return(list(Lh=Lh,Phi=Phi,Th=Th,Table=NULL,method,orthogonal=orthogonal))\n}\n\nprint.FLS <- function(x, sort=TRUE, num.digits=3, cutoff=.25, ...)\n{\n  Lambda <- unclass(x$F)\n  \n  p <- nrow(Lambda)\n  factors <- ncol(Lambda)\n  if (sort) {\n    mx <- max.col(abs(Lambda))\n    ind <- cbind(1L:p, mx)\n    mx[abs(Lambda[ind]) < 0.5] <- factors + 1\n    Lambda <- Lambda[order(mx, 1L:p),]\n  }\n  fx <- format(round(Lambda, num.digits))\n  names(fx) <- NULL\n  nc <- nchar(fx[1L], type=\"c\")\n  fx[abs(Lambda) < cutoff] <- paste(rep(\" \", nc), collapse = \"\")\n  print(fx, quote = FALSE, ...)\n  vx <- colSums(Lambda^2)\n  varex <- rbind(\"SS loadings\" = vx)\n  if(is.null(attr(x, \"covariance\"))) {\n    varex <- rbind(varex, \"Proportion Var\" = vx/p)\n    if(factors > 1)\n      varex <- rbind(varex, \"Cumulative Var\" = cumsum(vx/p))\n  }\n  cat(\"\\n\")\n  print(round(varex, num.digits))\n  \n  if(!is.null(x$Phi)){\n    cat(\"\\nFactor Intercorrelations\\n\")\n    cat(\"------------------------\\n\")\n    print(round(unclass(x$Phi),num.digits))  \n  }\n  invisible(x)\n}\n\nprint.MLFA<-function(x,num.digits=3,cutoff=0.25,...){\n  cat(\"\\nUnrotated Loadings\\n------------------\\n\")\n  print.FLS(x$Unrotated,num.digits=num.digits,cutoff=cutoff)\n  cat(\"\\nVarimax Loadings\\n------------------\\n\")\n  print.FLS(x$Varimax,num.digits=num.digits,cutoff=cutoff)\n  cat(\"\\nPromax Loadings\\n-----------------\\n\")\n  print.FLS(x$Promax,num.digits=num.digits,cutoff=cutoff)\n  cat(\"\\nQuartimin Loadings\\n-----------------\\n\")\n  print.FLS(x$Quartimin,num.digits=num.digits,cutoff=cutoff)\n  cat(\"\\nOrthogonal Bifactor Loadings\\n---------------------------\\n\")\n  print.FLS(x$Bifactor,num.digits=num.digits,cutoff=cutoff)\n  cat(\"\\nOblique Bifactor Loadings\\n-------------------------\\n\")\n  invisible(print.FLS(x$BifactorOblique,num.digits=num.digits,cutoff=cutoff))\n}\n\nMLFA <- function(Correlation.Matrix=NULL,n.factors=NA,n.obs=NA,data=NULL,Factor.Pattern=NULL,random.starts=15,maxit=1000,num.digits=3,cutoff=0.30,promax.m=3){\n  cat(\"This will take a moment.\")\n  if(!is.null(Correlation.Matrix)&&is.null(data)){\n    R <- Correlation.Matrix\n    p <- dim(R)[1]\n    A <- factanal(covmat=R,n.obs=n.obs,factors=n.factors,maxit=maxit,\n                  rotation=\"none\")$loadings[1:p,]\n  }\n  \n  if(!is.null(data))\n  {R <- cor(data)\n   n.obs <- dim(data)[1]\n   p <- dim(R)[1]\n   A <- factanal(covmat=R,n.obs=n.obs,factors=n.factors,maxit=maxit,\n                 rotation=\"none\")$loadings[1:p,]}\n  if(is.null(data)&&is.null(Correlation.Matrix)){ A <- Factor.Pattern\n                                                  p <- dim(A)[1]\n  }\n  m <- dim(A)[2]\n  factor.labels <- paste(\"Factor\",1:m,sep=\"\")\n  A.varimax <- varimax(A)$loadings[1:p,]\n  o = TRUE\n  res <- list(Lh=A.varimax,orthogonal=o)\n  res <- FixPattern(res)\n  A.varimax <- list(F=res$Lh)\n  res <- GPromax(A,pow=promax.m)\n  res <- list(Lh=res$Lh,Phi=res$Phi,orthogonal=FALSE)\n  res <- FixPattern(res)\n  Phi.promax <- res$Phi\n  A.promax <- list(F=res$Lh,Phi=Phi.promax,orthogonal=FALSE)\n  cat(\".\")\n  res <- FindBestPattern(A,\"quartimin\",reps=random.starts,is.oblique=TRUE)\n  res <- list(Lh=res$Lh,Phi=res$Phi,orthogonal=FALSE)\n  res <- FixPattern(res)\n  Phi.quartimin <- res$Phi\n  A.quartimin <- list(F=res$Lh,Phi = Phi.quartimin)\n  cat(\".\")\n  res <- FindBestPattern(A,\"bifactor\",reps=random.starts)\n  orthogonal=TRUE\n  res <- list(Lh=res$Lh,Phi=res$Phi,orthogonal=orthogonal)\n  res <- FixPattern(res)\n  Phi=NULL\n  A.bifactor <- list(F=res$Lh,Phi=Phi)\n  cat(\".\")\n  res <- FindBestPattern(A,\"bifactor\",reps=random.starts,is.oblique=TRUE)\n  res <- list(Lh=res$Lh,Phi=res$Phi,orthogonal=FALSE)\n  res <- FixPattern(res)\n  cat(\".\")\n  Phi.bifactor.oblique <- res$Phi\n  A.bifactor.oblique <- list(F=res$Lh,Phi=Phi.bifactor.oblique)\n  A = list(F=A,Phi=NULL)\n  cat(\".\")\n  class(A.promax)=\"FLS\"\n  class(A)=\"FLS\"\n  class(A.quartimin)=\"FLS\"\n  cat(\".exiting\\n\")\n  class(A.varimax)=\"FLS\"\n  class(A.bifactor)=\"FLS\"\n  class(A.bifactor.oblique)=\"FLS\"\n  output<-list(Unrotated = A, \n               Varimax=A.varimax,\n               Promax = A.promax,\n               Quartimin = A.quartimin,\n               Bifactor  = A.bifactor,\n               BifactorOblique = A.bifactor.oblique  )\n  class(output) = \"MLFA\"\n  return(output)\n}\n\nLoadings <- function(x,num.digits=3,cutoff=.25){\n  invisible(print.MLFA(x,cutoff=cutoff,num.digits=num.digits))\n}\n\nFAtoCFA <-  function(x,model.name=\"fit\",cutoff=0.30,factor.names=colnames(x$F),reference.indicators=FALSE,covs=paste(factor.names, collapse=\",\")){\n  F <- x$F\n  fname <- paste(model.name,\".r\",sep=\"\")\n  file.create(fname)\n  rn <- rownames(F)\n  p <- dim(F)[1]\n  m <- dim(F)[2]\n  line <- rep(\" \",m)\n  for (j in 1:m) {\n    prefix <- paste(factor.names[j],\":\",sep=\"\")\n    count <- sum(abs(F[,j]>cutoff))\n    postfix <- rep(\" \",count)\n    i.postfix <- 0\n    for(i in 1:p){\n      if(abs(F[i,j])> cutoff){\n        i.postfix <- i.postfix + 1\n        if(i.postfix<count) postfix[i.postfix] <- paste(rn[i],\", \",sep=\"\")else postfix[i.postfix] <- paste(rn[i],\"\\n\",sep=\"\")\n      }\n    }\n    postfix <- paste(postfix,collapse='')\n    line[j] <- paste(prefix,postfix)  \n    cat(line[j],file=fname,append=TRUE)\n  }\n  cat(\"\\n\",file=fname,append=TRUE)\n  cstring <- paste(  c(\"cfa(reference.indicators=reference.indicators,covs=covs,\n                       file=\\\"\",fname,\"\\\")\"),collapse=\"\")\n  cfa.model <- eval(parse(text=cstring))\n  return(cfa.model)\n}\n\nFAtoREF <-  function(x,R,model.name=\"fit\",factor.names=colnames(x$F),\n                     make.start.values=TRUE,cov.matrix=TRUE,num.digits=4){\n  F <- round(x$F,num.digits)\n  fname <- paste(model.name,\".r\",sep=\"\")\n  file.create(fname)\n  Phi <- x$Phi\n  rn <- rownames(F)\n  p <- dim(F)[1]\n  m <- dim(F)[2]\n  #  cat(paste(model.name,\"<- cfa(reference.indicators=FALSE)\\n\"))\n  line <- rep(\" \",p-(m-1))\n  ref.position <- rep(NA,m)\n  par.number <- 0\n  for (j in 1:m)ref.position[j] <- order(F[,j])[p]\n  ## Got reference positions -- if start values are needed, compute them\n  ## Now, construct the transformation matris\n  ## First, pull out F1\n  F1 <- F[ref.position[1],]\n  for (j in 2:m) F1 <- rbind(F1,F[ref.position[j],])\n  ## Got F1, now compute T and then rotate F and compute Phi\n  if(make.start.values){\n    T <- solve(F1) %*% diag ( sqrt( diag(F1 %*% t(F1) ) ) )\n    F <- F %*% T\n    Tinv <- solve(T)\n    Phi <- Tinv %*% t(Tinv)\n  }\n  for (j in 1:m) {\n    prefix <- paste(factor.names[j],\" -> \",sep=\"\")\n    for(i in 1:p){\n      postfix <- rn[i]\n      non.fixed=TRUE\n      line.out=FALSE\n      for(jj in 1:m)\n      {\n        if(i == ref.position[jj]&&jj==j)\n        {\n          non.fixed=TRUE\n          line.out=TRUE}\n        if(i == ref.position[jj]&&jj!=j)\n          non.fixed=FALSE\n      } \n      if(non.fixed){\n        \n        par.number <- par.number + 1\n        par.name <- paste(\"Theta\",as.character(par.number),sep=\"\")\n        if(make.start.values)\n          sv<-paste(c(\", \",as.character(round(F[i,j],num.digits)),\"\\n\"),collapse=\"\")else  sv <- \", NA\\n\"\n        postfix <- paste(c(postfix,\", \",par.name,sv),collapse=\"\")\n        line.out=TRUE\n      }\n      \n      \n      if(line.out){\n        line <- paste(c(prefix,postfix),collapse=\"\")  \n        cat(line,file=fname,append=TRUE)\n      }\n    }\n  }\n  for(j in 1:m)\n  {\n    cat(paste(c(factor.names[j],\" <-> \",factor.names[j],\", NA, 1\\n\"),collapse=\"\"),file=fname,append=TRUE)\n  }\n  if(cov.matrix && m>1 )  \n  {\n    ok <- !is.null(Phi)\n    for(i in 2:m)\n      for(j in 1:(i-1))\n      { \n        par.number <- par.number + 1\n        prefix <- paste(factor.names[i], \"<-> \",sep=\"\")\n        postfix <- factor.names[j]\n        if(make.start.values&&ok)\n          sv<-paste(c(\", \",as.character(round(Phi[i,j],num.digits)),\"\\n\"),collapse=\"\") else  sv <- \", NA\\n\"\n        par.name <- paste(\"Theta\",as.character(par.number),sep=\"\")\n        postfix <- paste(c(postfix,\", \",par.name,sv),collapse=\"\")\n        cat(paste(c(prefix,postfix),collapse=\"\"),file=fname,append=TRUE)  \n      }\n  }  \n  ## add unique variances\n  if(is.null(Phi))Phi <- diag(p)\n  U2 <- diag(R - F %*% Phi %*% t(F))\n  for(i in 1:p){\n    par.number <- par.number+1\n    prefix <- paste(c(rn[i],\" <-> \",rn[i],\", \"),collapse=\"\")\n    par.name <- paste(\"Theta\",as.character(par.number),sep=\"\")\n    if(make.start.values)\n      sv<-paste(c(\", \",as.character(round(U2[i],num.digits)),\"\\n\"),collapse=\"\") else  sv <- \", NA\\n\"\n    cat(paste(c(prefix,par.name,sv),collapse=\"\"),file=fname,append=TRUE)  \n  }\n  \n  cat(\"\\n\",file=fname,append=TRUE)\n  cstring <- paste(  c(\"specifyModel(file=\\\"\",fname,\"\\\")\"),collapse=\"\")\n  sem.model <- eval(parse(text=cstring))\n  return(sem.model)\n}\n\nFAtoSEM <-  function(x,model.name=\"fit\",cutoff=0.30,factor.names=colnames(x$F),\n                     make.start.values=FALSE,cov.matrix=FALSE,num.digits=4){\n  F <- round(x$F,num.digits)\n  fname <- paste(model.name,\".r\",sep=\"\")\n  file.create(fname)\n  cat(\"\\n\")\n  Phi <- x$Phi\n  rn <- rownames(F)\n  p <- dim(F)[1]\n  m <- dim(F)[2]\n  #  cat(paste(model.name,\"<- cfa(reference.indicators=FALSE)\\n\"))\n  line <- rep(\" \",p-(m-1))\n  par.number <- 0\n  for (j in 1:m) {\n    prefix <- paste(factor.names[j],\" -> \",sep=\"\")\n    for(i in 1:p){\n      postfix <- rn[i]\n      if(abs(F[i,j])>cutoff)\n      {\n        par.number <- par.number + 1\n        par.name <- paste(\"Theta\",as.character(par.number),sep=\"\")\n        if(make.start.values)\n        {sv<-paste(c(\", \",as.character(F[i,j]),\"\\n\"),collapse=\"\")}else sv <- \", NA\\n\"\n        postfix <- paste(c(postfix,\", \",par.name,sv),collapse=\"\")\n        line <- paste(c(prefix,postfix),collapse=\"\")  \n        cat(line,file=fname,append=TRUE)\n      } \n    }\n  }\n  for(j in 1:m)\n  {\n    cat(paste(c(factor.names[j],\" <-> \",factor.names[j],\", NA, 1\\n\"),collapse=\"\"),file=fname,append=TRUE)\n  }\n  if(cov.matrix && m>1 )  \n  {\n    ok <- !is.null(Phi)\n    for(i in 2:m)\n      for(j in 1:(i-1))\n      { \n        par.number <- par.number + 1\n        prefix <- paste(factor.names[i], \"<-> \",sep=\"\")\n        postfix <- factor.names[j]\n        if(make.start.values&&ok)sv<-paste(c(\", \",as.character(Phi[i,j]),\"\\n\"),collapse=\"\") else  sv <- \", NA\\n\"\n        par.name <- paste(\"Theta\",as.character(par.number),sep=\"\")\n        postfix <- paste(c(postfix,\", \",par.name,sv),collapse=\"\")\n        cat(paste(c(prefix,postfix),collapse=\"\"),file=fname,append=TRUE)  \n      }\n  }  \n  cat(\"\\n\",file=fname,append=TRUE)\n  cstring <- paste(  c(\"specifyModel(file=\\\"\",fname,\"\\\")\"),collapse=\"\")\n  sem.model <- eval(parse(text=cstring))\n  return(sem.model)\n}\n\nGetPattern <- function(sem.object){\n  A <- sem.object$A\n  P <- sem.object$P\n  p <- sem.object$n\n  m <- sem.object$m - p\n  F <- A[1:p,(p+1):sem.object$m]\n  Phi <- P[(p+1):sem.object$m,(p+1):sem.object$m]\n  return(list(F=F,Phi=Phi))\n}\n\nSetupCFAPattern <- function(R,n.factors=NA,factor.names=NULL){\n  p <- dim(R)[1]\n  m <- n.factors\n  Fp <- matrix(0,p,m)\n  rownames(Fp) <- colnames(R)\n  if(is.null(factor.names))factor.names <- paste(\"Factor\",1:m,sep=\"\")\n  colnames(Fp) <- factor.names\n  Fp <- edit(Fp)\n  return(list(F=Fp))\n}\n\nUseMod <- function(sem.object,loadings.only=TRUE){\n  options(warn=-1)\n  new.path <- CheckMod(sem.object,row.form=TRUE,loadings.only=loadings.only)$NewPath\n  old.model <- sem.object$semmod\n  R <- sem.object$S\n  n.obs <- sem.object$N\n  new.model <- rbind(old.model,new.path)\n  class(new.model) <- class(old.model)\n  fit.object <- sem(new.model,R,n.obs)\n  return(fit.object)\n}\n\nCFAModel <- function(R,model.name=\"fit\",n.factors=NULL,factor.names=NULL,cutoff=0.30,covs=TRUE,reference.indicators=FALSE)\n{\n  if(is.null(n.factors))n.factors=length(factor.names)\n  x <- SetupCFAPattern(R,n.factors,factor.names)\n  if(covs){\n    covariances=paste(factor.names, collapse=\",\")\n  }else{covariances=NULL}\n  model <- FAtoCFA(x,model.name,cutoff,factor.names,reference.indicators,covariances)\n  return(model)\n}\n\nQuickCFA <- function(R,n.factors=NULL,n.obs,model.name=\"Model0\",\n                     factor.names=NULL,cutoff=0.30,factor.correlations=FALSE,\n                     reference.indicators=FALSE)\n{\n  model <- CFAModel(R,model.name,n.factors,factor.names,cutoff,\n                    covs=factor.correlations,reference.indicators)\n  fit.object <- sem(model,R,n.obs)\n  return(fit.object)\n}\n\nCheckMod <- function(sem.object,row.form=FALSE,loadings.only=TRUE){\n  options(warn=-1)\n  mi <- modIndices(sem.object)\n  A <- mi$mod.A\n  P <- mi$mod.P\n  p <- sem.object$n\n  m <- sem.object$m - p\n  F <- A[1:p,(p+1):sem.object$m]\n  par.number <- sem.object$t + 1\n  par.name <- paste(\"AddedTheta\",par.number,sep=\"\")\n  largest.F <- max(F,na.rm=TRUE)\n  largest.P <- 0\n  largest.Q <- 0\n  if(!loadings.only){\n    Q <- P\n    P <- P[(p+1):sem.object$m,(p+1):sem.object$m]\n    Q <- Q[1:p,1:p]\n    largest.P <- max(P,na.rm=TRUE)\n    largest.Q <- max(Q,na.rm=TRUE)\n  }\n  maxes <- c(largest.F,largest.P,largest.Q)\n  for(i in 1:3)if(maxes[i]==-Inf)maxes[i]<-0\n  max.mod.pos <- order(maxes,decreasing=TRUE)[1]\n  if(max.mod.pos == 1){\n    arrow <- \"->\"\n    F.pos <- which(F==largest.F,arr.ind=TRUE)\n    if(length(F.pos[,1])>1)F.pos <- F.pos[1,]\n    postfix <- rownames(F)[F.pos[1]]\n    prefix <- colnames(F)[F.pos[2]]\n    value <- F[F.pos[1],F.pos[2]]\n  }\n  if(max.mod.pos==2){\n    arrow=\"<->\"\n    P.pos <- which(P==largest.P,arr.ind=TRUE)\n    if(length(P.pos[,1])>1)P.pos <- P.pos[1,]\n    prefix <- colnames(P)[P.pos[1]]\n    postfix <- colnames(P)[P.pos[2]]\n    value <- P[P.pos[1],P.pos[2]]\n  }\n  if(max.mod.pos==3){\n    arrow=\"<->\"\n    Q.pos <- which(Q==largest.Q,arr.ind=TRUE)\n    if(length(Q.pos[,1])>1)Q.pos <- Q.pos[1,]\n    prefix <- colnames(Q)[Q.pos[1]]\n    postfix <- colnames(Q)[Q.pos[2]]\n    value <- Q[Q.pos[1],Q.pos[2]]\n  }\n  path <- paste(c(prefix,arrow,postfix),collapse=\"\")\n  if(!row.form)line <- paste(c(path,\",\",par.name,\", NA\"),collapse=\"\")else line <- c(path,par.name,\", NA\")\n  fname=\"added.r\"\n  file.create(fname)\n  cat(line,file=fname)\n  output  <- list(NewPath=line,ModIndex=value)\n  return(output)  \n}\nCullModel<-function(fit.object,alpha,cull.Phi=FALSE){\n  model <- fit.object$semmod\n  zcrit <- qnorm(1-alpha/2)\n  zval <- summary(fit.object)$coeff$'z value'\n  sig <- abs(zval)>zcrit\n  par.posn <- fit.object$par.posn\n  new.model <- model\n  model.length <- dim(model)[1]\n  pos<-1\n  to.cull <- 0\n  is.ok <- rep(TRUE,model.length)\n  if(!cull.Phi){\n    do.not.cull <- grep(\"<->\",model)\n    for(i in 1:length(do.not.cull)){\n      is.ok[do.not.cull[i]]<-FALSE\n    }\n  }\n  for(i in 1:length(sig)){\n    if(!sig[i]&&is.ok[par.posn[i]]){\n      to.cull[pos] <- par.posn[i]\n      pos <- pos+1\n    }\n  }\n  new.model <- new.model[-to.cull,]\n  class(new.model) <- class(model)\n  return(new.model)\n}  \n\nQuickJoreskog <- function(R,n.factors,n.obs,model.name=\"model.0\",alpha=0.05,use.promax=FALSE,promax.m=3){\n  mlfa.object <- MLFA(R,n.factors,n.obs,promax.m=promax.m)\n  if(use.promax)x <- mlfa.object$Promax else x <- mlfa.object$Varimax\n  ref.model <- FAtoREF(x,R,model.name)\n  ref.fit <- sem(ref.model,R,n.obs)\n  culled.model <- CullModel(ref.fit,alpha)\n  culled.fit <- sem(culled.model,R,n.obs)\n  return(culled.fit)\n}\n\nGetPrettyPattern <- function(fit.object,cutoff=0.10){\n  print.FLS(GetPattern(fit.object),cutoff=cutoff)}\n\nRMSEA <- function(fit.object,conf=0.90){\n  n.obs <- fit.object$N\n  X2 <- (n.obs-1)*fit.object$criterion\n  p <- fit.object$n\n  t <- fit.object$t\n  df <- p*(p+1)/2 - t\n  rmsea.ci(X2,df,n.obs,conf)\n}\nQuickEFAtoCFA <- function(R,n.factors,n.obs,rotation=\"Varimax\",model.name=\"model.0\",cutoff=0.30,alpha=0.05,make.start.values=TRUE,cov.matrix=TRUE,num.digits=4,promax.m=3){\n  rotation.list <- c(\"Varimax\",\"Promax\",\"Quartimin\",\"Bifactor\", \"BifactorOblique\")\n  rot <- 0\n  for(i in 1:5)\n    if(rotation==rotation.list[i]){rot<-i;break}  \n  if(rot==0){print(\"Illegal Rotation Methods\");return()}\n  x <- MLFA(R,n.factors,n.obs,cutoff=cutoff,num.digits=num.digits,promax.m=promax.m)   \n  cstring <- paste(  c(\"rot.pattern <-x$\",rotation),collapse=\"\")\n  eval(parse(text=cstring))\n  model <- FAtoSEM(rot.pattern,model.name=model.name,cutoff=cutoff,\n                   factor.names=colnames(rot.pattern$F),\n                   make.start.values=make.start.values,cov.matrix=cov.matrix,num.digits=num.digits)\n  fit <- sem(model,R,n.obs)\n  return(fit)\n}\n",
    "created" : 1426529097791.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "654801179",
    "id" : "1BB9E2F0",
    "lastKnownWriteTime" : 1425315790,
    "path" : "~/GitHub/psy533/Cases/Advanced CFA in R/AdvancedFactorFunctions.R",
    "project_path" : "Cases/Advanced CFA in R/AdvancedFactorFunctions.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}