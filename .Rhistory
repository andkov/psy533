str(ds) # examine the structure of the object
head(ds) # print the first few lines
noyesLevels<- c(0,1)
noyesLabels<- c("NO", "YES")
varlist <- colnames(ds)
for(i in varlist){
ds[,i)]<- ordered(ds[,i],
levels = noyesLevels,
labels = noyesLabels)
}
noyesLevels
noyesLabels
colnames(ds)
varlist
noyesLevels<- c(0,1)
noyesLabels<- c("NO", "YES")
varlist <- colnames(ds)
for(i in varlist){
ds[,i]<- ordered(ds[,i], levels = noyesLevels,labels = noyesLabels)
}
str(ds) # examine the structure of the object
ds <- read.table(pathFile, as.is=T) # read in the data
head(ds) # print the first few lines
str(ds) # examine the structure of the object
ds <- read.table(pathFile, as.is=T) # read in the data
head(ds) # print the first few lines
str(ds) # examine the structure of the object
# convert "." into missing values
ds[ds == "."] <- NA
# convert into factors and assign labels
noyesLevels<- c(0,1)
noyesLabels<- c("NO", "YES")
varlist <- colnames(ds)
for(i in varlist){
ds[,i]<- factor(ds[,i], levels = noyesLevels,labels = noyesLabels)
}
str(ds) # examine the structure of the object
R <- corr(ds)
library(Hmisc)# multipurpose
R <- corr(ds)
R <- cor(ds)
#### SETUP ####
rm(list=ls(all=TRUE)) #Clear out variables from previous runs.
options("scipen"=10, "digits"=5) # control the decimal places in the output
# Install packages if necessary
# install.packages("psych")
# install.packages("corrgram")
## load the packages
library(psych) # multipurpose for psychologist
library(corrgram) # for graphing correlation matrices
library(Hmisc)# multipurpose
library(sem) # structural equation modeling
library(reshape2) # data transformation
library(ggplot2) # general graphing
library(plotrix) # ploting matrix graphs
# Please consult the website of James Steiger (www.statpower.net) for all materials pertaining to this demonstration. ( See Psychology 312)
## load some custom functions
>>>>>>> origin/master
# Useful function for multivariate stats
source("http://statpower.net/Content/312/R%20Stuff/Steiger%20R%20Library%20Functions.txt")
# Functions to assist you in FA and SEM
source("http://statpower.net/Content/312/R%20Stuff/AdvancedFactorFunctions.txt")
# Functions by Dirk Enzmann to aid promax rotation
source("http://statpower.net/Content/312/R%20Stuff/fa.promax.R")
<<<<<<< HEAD
# Load Athletic data directly from James Stieger's website
AthleticsData <- read.csv("http://statpower.net/Content/312/Homework/AthleticsData.csv")
# attach(AthleticsData)
#          R            Correlation/Covariance matrix - R
#      F      F'        Grahm-Factors                 - F
#   VD1/2   D1/2V'      Principle Component patterns  - pcPattern
#   V     D     V'      Earhart-Young decomposition   - V, D
#      Rv = cv          Eigenvalues and Eigenvectors
R<-cor(AthleticsData) # correlation matrix R of variables in AthleticsData
eigen<-eigen(R) # eigen decomposition of R      #  VDV' : $values -eigenvalues, $vectors
svd<-svd(R)   # single value decomposition of R #  UDV' : $d      -eigenvalues, $u,$v
Ve<-eigen$vectors            # eigenvectors   from VDV' of R
De<-diag(eigen$values)       # eigenvalues    from VDV' of R
Us<-svd$u                     # eigenvectors U from UDV' of R
Ds<-diag(svd$d)               # eigenvalues    from UDV' of R
Vs<-svd$v                     # eigenvectors V from UDV' of R
Fe<-(Ve %*% sympower(De,1/2))      # principal component pattern F=V(D^1/2)
Fs<-(Vs) %*% sympower(Ds,1/2)  # same computed from UDV'
# Renaming for convenience
rownames(Ve)<-colnames(R)
rownames(De)<-colnames(R)
rownames(Us)<-colnames(R)
rownames(Ds)<-colnames(R)
rownames(Vs)<-colnames(R)
colnames(Ve)<-paste0("PC",1:ncol(R)) # name the components
colnames(De)<-paste0("PC",1:ncol(R)) # name the components
colnames(Us)<-paste0("PC",1:ncol(R)) # name the components
colnames(Ds)<-paste0("PC",1:ncol(R)) # name the components
colnames(Vs)<-paste0("PC",1:ncol(R)) # name the components
rownames(Fe)<-colnames(R)      # names the variables
rownames(Fs)<-colnames(R)      # names the variables
colnames(Fe)<-paste0("PC",1:ncol(R)) # name the components
colnames(Fs)<-paste0("PC",1:ncol(R))# name the components
# the values in eigen values are the a the same.
round(abs(Ve)-abs(Vs),3)
round(abs(Ve)-abs(Us),3)
round(abs(Vs)-abs(Us),3)
# but signs differ
sign(Ve)+sign(Vs)
sign(Ve)+sign(Us)
sign(Vs)+sign(Us)
R1<-Ve %*% De %*% t(Ve) # eigen decomposition  R = VDV'
round(sum((R-R1)^2),10) # should perfectly reconstruct = 0
R1s<- Us %*% Ds %*% t(Vs) # single value R = UDV'
round(((R-R1s)^2),10) # should perfectly reconstruct = 0
######### Compare VDV'(eigen) and UDV'(svd) solutions ##########################
str(R)
head(R)
svd$d
eigen$values
Ve                          # V from VDV'
svd$u                      # U from UDV'
round(abs(Ve)-abs(svd$u),2) # values are the same, signs differ
round(Ve-svd$u,2)           # but not for all columns!
Ve                          # V from VDV'
svd$v                      # V from UDV'
round(abs(Ve)-abs(svd$v),2) # values are the same, signs differ
round(Ve-svd$v,2)           # but not for all columns!
########################### this is because we work with square matrices
# Reconstruct R using Grahn Factors from VDV'
R2<-Fe%*%t(Fe) # R2 =(FF') (VD1/2)(VD1/2)'= (VDV') = R
round(sum((R-R2)^2),10) # should perfectly reconstruct = 0
# Reconstruct R using Grahn Factors from UDV'
R2s<-Fs%*%t(Fs) # Factors reconstruct UDV': R2s =(FF') = (VDV') =R
round(sum((R-R2s)^2),10) # should perfectly reconstruct = 0
# # But is is Graph Factor of
# pcPatternEV
# pcPatternSVD
# round((abs(pcPatternEV)-abs(pcPatternSVD) ),3) # values of loading are the same
# sign(round(((pcPatternEV-pcPatternSVD)),3)) # the sign differ
# solutions   [1]       [2]        [3]
solution<-c("eigen()", "svd()","principal()")
whatsolution<- solution[3]
# rotation   [1]      [2]       [3]       [4]       [5]       [6]        [7]
rotation<-c("none","varimax","quatimax","promax","oblimin","simplimax","cluster")
whatrotation<-as.character(rotation[1])
nfactors<-9
fit <- principal(r=AthleticsData, nfactors=nfactors, rotate=whatrotation)
fit # print results
# fit$values
# fit$loadings
# str(fit)
F<-fit$loadings[1:9,1:9]
# extract the parameter values from fitted object
eigens<-colSums(fit$loadings*fit$loadings) # eigenvalues
explained<-colSums(fit$loading*fit$loading)/dim(fit$loading)[1]  # variance explained
cumulative<-cumsum(colSums(fit$loading*fit$loading)/dim(fit$loading)[1]) # cummulative
# Create  D matrix with eigenvalues and thier informations
Dplus<-rbind(eigens,explained,cumulative)
# Ve       # Eigen decomposition, eigenvectors,  V from VDV' of R
# De       # Eigen decomposition, eigenvalues,   D from VDV' of R
# Us      # SVD decomposition,   eigenvectors,  U from UDV' of R
# Ds      # SVD decomposition,   eigenvalues,   D from UDV' of R
# Vs      # SVD decomposition,   eigenvectors,  V from UDV' of R
# Dplus   # Eigensvalues from solution of the dedicated routine
# Fe   # principal component pattern F=V(D^1/2) , from EiGenDecomposition
# Fs  # same computed from UDV' # from single value decomposition
# F     # pattern loading from function
#          R            Correlation/Covariance matrix - R
#      F      F'        Grahm-Factors                 - F
#   VD1/2   D1/2V'      Principle Component patterns  - pcPattern
#   V     D     V'      Earhart-Young decomposition   - V, D
#      Rv = cv          Eigenvalues and Eigenvectors
######   Producing graphs   # Ctrl+Alt+E - Run from line to end
pathScree<-file.path(getwd(),"Scripts/Functions/scree.R")
pathPattern<-file.path(getwd(),"Scripts/Functions/factor pattern.R")
colors<- c("darksalmon" ,"lightskyblue")
pathScree
source(pathScree)
library(ggplot)
Dplus
ds<-as.data.frame(t(Dplus))
ds$pc<-c(1:ncol(Dplus))
# Scree
p2<-ggplot(ds, aes(x=pc,y=eigens))+
ggtitle(title2)+
geom_abline(intercept=1,slope=0,color="red",linetype="dashed")+
geom_line()+
geom_point()+
scale_y_continuous(limits=c(0,3))+
scale_x_discrete (limits=rev(c(1:ncol(R))))
p2
pathFileOut<-file.path(pathImageOut,paste0(drawing,"_",nfactors,"_",whatrotation,"_Scree",".png"))
png(filename = pathFileOut,
width =width2, height =height2 , units = "in",res=resolution2)
plot(p2)
dev.off()
# Variance Explained
p3<-ggplot(ds, aes(x=pc))+
ggtitle(title3)+
geom_line(y=explained,linetype=4)+
geom_point(y=explained)+
geom_line(y=cumulative,linetype=6)+
geom_point(y=cumulative)+
scale_y_continuous(limits=c(0,1),breaks=c(0,.2,.4,.6,.8,1))+
scale_x_discrete (limits=rev(c(1:ncol(R))))
p3
p2<-ggplot(ds, aes(x=pc,y=eigens))+
ggtitle(title2)+
geom_abline(intercept=1,slope=0,color="red",linetype="dashed")+
geom_line()+
geom_point()+
scale_y_continuous(limits=c(0,3))+
scale_x_discrete (limits=rev(c(1:ncol(R))))
p2
ds<-as.data.frame(t(Dplus))
ds$pc<-c(1:ncol(Dplus))
ds$pc
p2<-ggplot(ds, aes(x=pc,y=eigens))+
ggtitle(title2)+
geom_abline(intercept=1,slope=0,color="red",linetype="dashed")+
geom_line()+
geom_point()+
scale_y_continuous(limits=c(0,3))+
scale_x_discrete (limits=rev(c(1:ncol(R))))
p2
ggplot(ds, aes(x=pc,y=eigens))
library(ggplot)
library(ggplot2)
ds<-as.data.frame(t(Dplus))
ds$pc<-c(1:ncol(Dplus))
# Scree
p2 <- ggplot(ds, aes(x=pc,y=eigens))+
ggtitle(title2)+
geom_abline(intercept=1,slope=0,color="red",linetype="dashed")+
geom_line()+
geom_point()+
scale_y_continuous(limits=c(0,3))+
scale_x_discrete (limits=rev(c(1:ncol(R))))
p2
ggplot(ds, aes(x=pc,y=eigens))
p2 <- ggplot(ds, aes(x=pc,y=eigens))+
ggtitle(title2)+
geom_abline(intercept=1,slope=0,color="red",linetype="dashed")+
geom_line()+
geom_point()+
scale_y_continuous(limits=c(0,3))+
scale_x_discrete (limits=rev(c(1:ncol(R))))
p2
rm(list=ls(all=TRUE)) #Clear out variables from previous runs.
options("scipen"=10, "digits"=5)
######### Set Up Working Directory!!
library(Hmisc)
library(sem)
library(corrgram)
library(psych)
library(sem)
library(ggplot2)
# Please consult the website of James Steiger (www.statpower.net) for all materials pertaining to this demonstration.
=======
pathHome <- getwd()
pathFile <- file.path(pathHome,"Homework/HW3.txt")
pathVarnames <- file.path(pathHome,"Homework/varnames.txt")
#### Data prep ####
ds <- read.table(pathFile, as.is=T) # read in the data
head(ds) # print the first few lines
str(ds) # examine the structure of the object
# convert "." into missing values
ds[ds == "."] <- NA
ds[ds == "NO"] <- 0
ds[ds == "YES"] <- 1
R <- cor(ds)
str(ds) # examine the structure of the object
#### SETUP ####
rm(list=ls(all=TRUE)) #Clear out variables from previous runs.
options("scipen"=10, "digits"=5) # control the decimal places in the output
# Install packages if necessary
# install.packages("psych")
# install.packages("corrgram")
## load the packages
library(psych) # multipurpose for psychologist
library(corrgram) # for graphing correlation matrices
library(Hmisc)# multipurpose
library(sem) # structural equation modeling
library(reshape2) # data transformation
library(ggplot2) # general graphing
library(plotrix) # ploting matrix graphs
# Please consult the website of James Steiger (www.statpower.net) for all materials pertaining to this demonstration. ( See Psychology 312)
## load some custom functions
>>>>>>> origin/master
# Useful function for multivariate stats
source("http://statpower.net/Content/312/R%20Stuff/Steiger%20R%20Library%20Functions.txt")
# Functions to assist you in FA and SEM
source("http://statpower.net/Content/312/R%20Stuff/AdvancedFactorFunctions.txt")
# Functions by Dirk Enzmann to aid promax rotation
source("http://statpower.net/Content/312/R%20Stuff/fa.promax.R")
<<<<<<< HEAD
# Load Athletic data directly from James Stieger's website
AthleticsData <- read.csv("http://statpower.net/Content/312/Homework/AthleticsData.csv")
# attach(AthleticsData)
#          R            Correlation/Covariance matrix - R
#      F      F'        Grahm-Factors                 - F
#   VD1/2   D1/2V'      Principle Component patterns  - pcPattern
#   V     D     V'      Earhart-Young decomposition   - V, D
#      Rv = cv          Eigenvalues and Eigenvectors
R<-cor(AthleticsData) # correlation matrix R of variables in AthleticsData
eigen<-eigen(R) # eigen decomposition of R      #  VDV' : $values -eigenvalues, $vectors
svd<-svd(R)   # single value decomposition of R #  UDV' : $d      -eigenvalues, $u,$v
Ve<-eigen$vectors            # eigenvectors   from VDV' of R
De<-diag(eigen$values)       # eigenvalues    from VDV' of R
Us<-svd$u                     # eigenvectors U from UDV' of R
Ds<-diag(svd$d)               # eigenvalues    from UDV' of R
Vs<-svd$v                     # eigenvectors V from UDV' of R
Fe<-(Ve %*% sympower(De,1/2))      # principal component pattern F=V(D^1/2)
Fs<-(Vs) %*% sympower(Ds,1/2)  # same computed from UDV'
# Renaming for convenience
rownames(Ve)<-colnames(R)
rownames(De)<-colnames(R)
rownames(Us)<-colnames(R)
rownames(Ds)<-colnames(R)
rownames(Vs)<-colnames(R)
colnames(Ve)<-paste0("PC",1:ncol(R)) # name the components
colnames(De)<-paste0("PC",1:ncol(R)) # name the components
colnames(Us)<-paste0("PC",1:ncol(R)) # name the components
colnames(Ds)<-paste0("PC",1:ncol(R)) # name the components
colnames(Vs)<-paste0("PC",1:ncol(R)) # name the components
rownames(Fe)<-colnames(R)      # names the variables
rownames(Fs)<-colnames(R)      # names the variables
colnames(Fe)<-paste0("PC",1:ncol(R)) # name the components
colnames(Fs)<-paste0("PC",1:ncol(R))# name the components
# the values in eigen values are the a the same.
round(abs(Ve)-abs(Vs),3)
round(abs(Ve)-abs(Us),3)
round(abs(Vs)-abs(Us),3)
# but signs differ
sign(Ve)+sign(Vs)
sign(Ve)+sign(Us)
sign(Vs)+sign(Us)
R1<-Ve %*% De %*% t(Ve) # eigen decomposition  R = VDV'
round(sum((R-R1)^2),10) # should perfectly reconstruct = 0
R1s<- Us %*% Ds %*% t(Vs) # single value R = UDV'
round(((R-R1s)^2),10) # should perfectly reconstruct = 0
######### Compare VDV'(eigen) and UDV'(svd) solutions ##########################
str(R)
head(R)
svd$d
eigen$values
Ve                          # V from VDV'
svd$u                      # U from UDV'
round(abs(Ve)-abs(svd$u),2) # values are the same, signs differ
round(Ve-svd$u,2)           # but not for all columns!
Ve                          # V from VDV'
svd$v                      # V from UDV'
round(abs(Ve)-abs(svd$v),2) # values are the same, signs differ
round(Ve-svd$v,2)           # but not for all columns!
########################### this is because we work with square matrices
# Reconstruct R using Grahn Factors from VDV'
R2<-Fe%*%t(Fe) # R2 =(FF') (VD1/2)(VD1/2)'= (VDV') = R
round(sum((R-R2)^2),10) # should perfectly reconstruct = 0
# Reconstruct R using Grahn Factors from UDV'
R2s<-Fs%*%t(Fs) # Factors reconstruct UDV': R2s =(FF') = (VDV') =R
round(sum((R-R2s)^2),10) # should perfectly reconstruct = 0
# # But is is Graph Factor of
# pcPatternEV
# pcPatternSVD
# round((abs(pcPatternEV)-abs(pcPatternSVD) ),3) # values of loading are the same
# sign(round(((pcPatternEV-pcPatternSVD)),3)) # the sign differ
# solutions   [1]       [2]        [3]
solution<-c("eigen()", "svd()","principal()")
whatsolution<- solution[3]
# rotation   [1]      [2]       [3]       [4]       [5]       [6]        [7]
rotation<-c("none","varimax","quatimax","promax","oblimin","simplimax","cluster")
whatrotation<-as.character(rotation[1])
nfactors<-9
fit <- principal(r=AthleticsData, nfactors=nfactors, rotate=whatrotation)
fit # print results
# fit$values
# fit$loadings
# str(fit)
F<-fit$loadings[1:9,1:9]
# extract the parameter values from fitted object
eigens<-colSums(fit$loadings*fit$loadings) # eigenvalues
explained<-colSums(fit$loading*fit$loading)/dim(fit$loading)[1]  # variance explained
cumulative<-cumsum(colSums(fit$loading*fit$loading)/dim(fit$loading)[1]) # cummulative
# Create  D matrix with eigenvalues and thier informations
Dplus<-rbind(eigens,explained,cumulative)
# Ve       # Eigen decomposition, eigenvectors,  V from VDV' of R
# De       # Eigen decomposition, eigenvalues,   D from VDV' of R
# Us      # SVD decomposition,   eigenvectors,  U from UDV' of R
# Ds      # SVD decomposition,   eigenvalues,   D from UDV' of R
# Vs      # SVD decomposition,   eigenvectors,  V from UDV' of R
# Dplus   # Eigensvalues from solution of the dedicated routine
# Fe   # principal component pattern F=V(D^1/2) , from EiGenDecomposition
# Fs  # same computed from UDV' # from single value decomposition
# F     # pattern loading from function
#          R            Correlation/Covariance matrix - R
#      F      F'        Grahm-Factors                 - F
#   VD1/2   D1/2V'      Principle Component patterns  - pcPattern
#   V     D     V'      Earhart-Young decomposition   - V, D
#      Rv = cv          Eigenvalues and Eigenvectors
######   Producing graphs   # Ctrl+Alt+E - Run from line to end
pathScree<-file.path(getwd(),"Scripts/Functions/scree.R")
pathPattern<-file.path(getwd(),"Scripts/Functions/factor pattern.R")
# palette <- choose_palette() # run to initiate a dialogue to choose palette
# colors<-palette(2) # assign the vector containing the N colorcodes
colors<- c("darksalmon" ,"lightskyblue")
#choose where the file will be stored
pathImageOut<-file.path(getwd(), "temp")
pattern<-F   # matrix for the factor pattern
drawing<- "F"  # name of file with graph
title<- paste0("Pattern values from ",whatsolution," \rotation : ",whatrotation,", Factors = ",nfactors)
ylims<-c(0,3)           # max for eigenvalue plot
width<-450              # width of pattern in pixels
height<-900             # height of pattern in pixels
width2<-300            # width of scree in pixels
height2<-200            # height of scree in pixels
# source(pathPattern) #produces the graph of pattern loadings
Dplus<- Dplus   # matrix with eigenvalues
title2<- paste0("Scree plot ",whatsolution," rotation : ",whatrotation)
title3<- paste0("Var Explnd from ",whatsolution,".","rotation - ",whatrotation)
source(pathScree)
ds<-as.data.frame(t(Dplus))
ds$pc<-c(1:ncol(Dplus))
# Scree
p2 <- ggplot(ds, aes(x=pc,y=eigens))+
ggtitle(title2)+
geom_abline(intercept=1,slope=0,color="red",linetype="dashed")+
geom_line()+
geom_point()+
scale_y_continuous(limits=c(0,3))+
scale_x_discrete (limits=rev(c(1:ncol(R))))
p2
install.packages("sem")
install.packages("Hmisc")
pathDir <- file.path("C:/Users/koval_000/Documents","Desktop/EFA with R")
R<-cor(AthleticsData) # correlation matrix R of variables in AthleticsData
R
corrgram(R)
library(corrgram)
??corrgram
corrgram(R)
corrgram(R,text.panel = T)
=======
pathHome <- getwd()
pathFile <- file.path(pathHome,"Homework/HW3.txt")
pathVarnames <- file.path(pathHome,"Homework/varnames.txt")
#### Data prep ####
ds <- read.table(pathFile, as.is=T) # read in the data
head(ds) # print the first few lines
str(ds) # examine the structure of the object
# convert "." into missing values
View(ds)
ds[ds == "."] <- NA
View(ds)
ds[ds == "NO"] <- 0
View(ds)
View(ds)
table(ds$v1)
table(ds$V1)
ds[ds == "No"] <- 0
ds[ds == "Yes"] <- 1
View(ds)
for(i in  colnames(ds)){
ds[,i]<- as.numeric(ds[,i])
}
str(ds) # examine the structure of the object
R <- cor(ds)
R
View(ds)
cor(ds$V1,ds$V2)
R <- cor(ds,use = "complete.obs")
View(R)
varNames <- paste(var,1:19)
varNames <- paste("var",1:19)
varNames
R <- cor(ds,use = "complete.obs")
R
options("scipen"=10, "digits"=3) # control the decimal places in the output
R
corrgram(R,upper.panel=panel.conf,lower.panel=panel.pie) # customize panels
corrgram(R,upper.panel=panel.conf,lower.panel=panel.pie, order = T) # sort by PCA
corrgram(R) # get the basic correlogram
corrgram(R,upper.panel=panel.conf,lower.panel=panel.pie) # customize panels
corrgram(R,upper.panel=panel.conf,lower.panel=panel.pie, order = T)
eigen(R)$values # examine eigenvalues directly
dim(ds)
nrow(ds)
Scree.Plot(R, main="Scree plot of 19 Psychological variables (n=702)") # plot the eigen values
FA.Stats(R, n.factors=1:10, n.obs=145, main="RMSEA plot of 19 Psych Variables (n=702)") # Request Chi-Square and RMSEA stats
FA.Stats(R, n.factors=1:10, n.obs=702, main="RMSEA plot of 19 Psych Variables (n=702)") # Request Chi-Square and RMSEA stats
ds1 <- na.rm(ds)
ds1 <- na.omit(ds)
View(ds1)
dim(ds)
ds <- na.omit(ds)
dim(ds)
R <- cor(ds)
# Print the corrleation matrix
R
# print a correlogram of the correlation matrix using corrgram() function of the corrgram package, use default options
corrgram(R)
corrgram(R,upper.panel=panel.conf,lower.panel=panel.pie)
# further customize the correlogram so that variable are ordered according to the PCA logic
corrgram(R,upper.panel=panel.conf,lower.panel=panel.pie, order = T)
eigen(R)$values
# Use Scree.Plot() function to request the graph of eigenvalues, add a descriptive title
Scree.Plot(R, main="Scree plot of 19 Psychological variables (n=360)") # plot the eigen values
#### Question 2 ####
# How many factors does the scree plot suggest to extract? Explain your reasoning
# A: 3, 4, or 5, depending on the rules you adopt in decision making
# Use FA.Stats() function to request Chi-Square and RMSEA statistics, add a descriptive title
FA.Stats(R, n.factors=1:10, n.obs=360, main="RMSEA plot of 19 Psych Variables (n=360)") # Request Chi-Square and RMSEA stats
out <- MLFA(Correlation.Matrix = R, n.factors=4, n.obs=360) # conduct MLFA and collect all rotations in a single object
Loadings(out, cutoff=.3, num.digits=2)
Loadings(out, cutoff=.3, num.digits=2)
FA.Stats(R, n.factors=1:10, n.obs=150, main="RMSEA plot of 19 Psych Variables (n=360)") # Request Chi-Square and RMSEA stats
>>>>>>> origin/master
